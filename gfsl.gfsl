include "std/std.gfsl"

define usage as 
    // stream str
    "Usage: %s [OPTIONS] input-file-path\n"	  eputs
    "OPTIONS:\n"				  eputs
    "    -h          print this help in stdout\n" eputs
    "    -o <path>   provide output path\n"	  eputs
    "    sim         simulate the program\n"	  eputs
    "    com         compile the program\n"       eputs
end

// CONSTANTS -----------------------------
define BUFFER_MEMORY_CAPACITY	  as 69000  end
define SIMULATION_STACK_CAPACITY  as 1024   end
define putd-buffer		  as mem    end
define PUTD-BUFFER-CAPACITY	  as 32	    end
define sim-stack-count		  as putd-buffer PUTD-BUFFER-CAPACITY + end
define sim-stack		  as sim-stack-count 8 +		end
// OPERATIONS START ----------------------
define OP_INTRISIC_PLUS as 0 end
define OP_PUSH_INT	as 1 end
define OP_DUMP		as 2 end
define NUM_OF_OPS	as 3 end
// OPERATIONS END ------------------------
define sizeof(op)	as 16	end
define ops-count	as sim-stack SIMULATION_STACK_CAPACITY 8 * + end
define ops		as ops-count 8 + end	

define push-op as
  // @stack: type operand
  ops-count 64-> sizeof(op) * ops +
  dup 8 + rot  64<-
	  swap 64<-
  ops-count inc64
end
// HARDCODED PROGRAM -------------------------------------
define program1 as 
  OP_PUSH_INT	    34	push-op 
  OP_PUSH_INT	    35	push-op
  OP_INTRISIC_PLUS  0	push-op
  OP_DUMP	    0	push-op
end
define program2 as
  OP_PUSH_INT	    35	push-op
  OP_PUSH_INT	    33	push-op
  OP_PUSH_INT	    1	push-op
  OP_INTRISIC_PLUS  0	push-op
  OP_INTRISIC_PLUS  0	push-op
  OP_DUMP	    0	push-op

end
// SIMULATION SECTION -------------------------------------

define sim-stack-push as 
  if sim-stack-count 64-> SIMULATION_STACK_CAPACITY >= do 
    here false ": ERROR: data stack overflow in simulation mode\n" assert
  end
  //
  sim-stack sim-stack-count 64-> 8 * + swap 64<-
  sim-stack-count inc64
end
define sim-stack-pop as 
  if sim-stack-count 64-> 0 = do
    here false ": ERROR: data stack underflow in simulation mode\n" assert
  end
  sim-stack-count dec64
  sim-stack sim-stack-count 64-> 8 * + 64->
end
define simulate-ops as
  here NUM_OF_OPS 3 = "Exhaustive handling operations in simulate-mode\n" assert
  0 while dup ops-count 64-> < do
    dup sizeof(op) * ops +

    if dup 64-> OP_PUSH_INT	  =  do dup 8 + 64-> sim-stack-push		      end
    if dup 64-> OP_INTRISIC_PLUS  =  do sim-stack-pop sim-stack-pop + sim-stack-push  end
    if dup 64-> OP_DUMP		  =  do sim-stack-pop dump			      end

    drop 
    1 +
  end
end
// COMPILATION SECTION -------------------------------------
define compile-ops as 
  here NUM_OF_OPS 3 = "Exhaustive handling operations in compile-mode\n" assert
  here false "compilation mode is not implemented yet\n" assert
  // TODO:
  //	External commands
  "BITS 64\n" puts
  "dump:\n" puts
  "  push  rbp\n"puts
  "  mov   rbp, rsp\n"puts
  "  sub   rsp, 64\n"puts
  "  mov   QWORD  [rbp-56], rdi\n"puts
  "  mov   QWORD  [rbp-8], 1\n"puts
  "  mov   eax, 32\n"puts
  "  sub   rax, QWORD  [rbp-8]\n"puts
  "  mov   BYTE  [rbp-48+rax], 10\n"puts
  ".L2:\n"puts
  "  mov   rcx, QWORD  [rbp-56]\n"puts
  "  mov   rdx, -3689348814741910323\n"puts
  "  mov   rax, rcx\n"puts
  "  mul   rdx\n"puts
  "  shr   rdx, 3\n"puts
  "  mov   rax, rdx\n"puts
  "  sal   rax, 2\n"puts
  "  add   rax, rdx\n"puts
  "  add   rax, rax\n"puts
  "  sub   rcx, rax\n"puts
  "  mov   rdx, rcx\n"puts
  "  mov   eax, edx\n"puts
  "  lea   edx, [rax+48]\n"puts
  "  mov   eax, 31\n"puts
  "  sub   rax, QWORD  [rbp-8]\n"puts
  "  mov   BYTE  [rbp-48+rax], dl\n"puts
  "  add   QWORD  [rbp-8], 1\n"puts
  "  mov   rax, QWORD  [rbp-56]\n"puts
  "  mov   rdx, -3689348814741910323\n"puts
  "  mul   rdx\n"puts
  "  mov   rax, rdx\n"puts
  "  shr   rax, 3\n"puts
  "  mov   QWORD  [rbp-56], rax\n"puts
  "  cmp   QWORD  [rbp-56], 0\n"puts
  "  jne   .L2\n"puts
  "  mov   eax, 32\n"puts
  "  sub   rax, QWORD  [rbp-8]\n"puts
  "  lea   rdx, [rbp-48]\n"puts
  "  lea   rcx, [rdx+rax]\n"puts
  "  mov   rax, QWORD  [rbp-8]\n"puts
  "  mov   rdx, rax\n"puts
  "  mov   rsi, rcx\n"puts
  "  mov   edi, 1\n"puts
  "  mov   rax, 1\n"puts
  "  syscall\n"puts
  "  nop\n"puts
  "  leave\n"puts
  "  ret\n"puts
  "global _start\n"puts
  "segment .text\n" puts
  "_start:\n" puts
  //"    mov [args_ptr], rsp\n" puts
  // TODO:
  // 	better if-else structure
  //  optype op 
  0 while dup ops-count 64-> < do
   dup sizeof(op) * ops +
   if dup 64-> OP_PUSH_INT = do 
     "    ;; ---- push int "puts dup 8 + 64-> dump
     "    push "	    puts dup 8 + 64-> dump
   end
   if dup 64-> OP_INTRISIC_PLUS = do  
     "    ;; ---- op-plus\n"  puts
     "    pop rbx\n"	      puts
     "    pop rax\n"	      puts
     "    add rax, rbx\n"     puts
     "    push rax\n"	      puts
   end 
   if dup 64-> OP_DUMP = do 
     "    ;; ---- call dump\n"	puts
     "    pop rdi\n"		puts
     "    call dump\n"		puts
   end drop 
   1 +
  end

   "segment .bss\n"	      puts
   "buffer:    resb " puts BUFFER_MEMORY_CAPACITY dump 
   // drop
end
define print-ops as
  0 while dup ops-count  64-> < do
    dup sizeof(op) * ops +
    "Type: "  eputs dup	    64-> dump
    "Op: "    eputs	8 + 64-> dump
    "--------------------\n" eputs
    1 +
  end drop
end
define main as 
  if __argc 64-> 2 < do
    stderr usage
    "ERROR: Not enough arguments\n" eputs
    1 exit
  end
  program2
  simulate-ops
end
//main
// 420 putd
//main
here "GFSL writed in itself" not-implemented
0 exit
