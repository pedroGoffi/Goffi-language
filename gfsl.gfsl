include "std/std.gfsl"

define usage as 
    dup "Usage: %s [OPTIONS] input-file-path\n"		rot fputs
    dup "OPTIONS:\n"					rot fputs
    dup "    -h          print this help in stdout\n"	rot fputs
    dup "    -o  <path>  provide output path\n"		rot fputs
    dup "    sim <file>  simulate the program\n"	rot fputs
    dup "    com <file>  compile the program\n"		rot fputs
    drop
end

// CONSTANTS -----------------------------
define BUFFER_MEMORY_CAPACITY	  as 69000  end
define SIMULATION_STACK_CAPACITY  as 1024   end
define PUTD-BUFFER-CAPACITY	  as 32	    end
define putd-buffer		  as mem    end
define sim-stack-count		  as putd-buffer PUTD-BUFFER-CAPACITY + end
define sim-stack		  as sim-stack-count 8 +		end
define int-iterator		  as sim-stack sizeof(size_t) + end
define input-file-path		  as int-iterator sizeof(size_t) + end
define goffi-mode		  as input-file-path sizeof(size_t) + end
define fd			  as goffi-mode 8 + end
define statbuffer		  as fd 8 + end
define file-content		  as statbuffer sizeof(stat) + end
define line-file-content	  as file-content sizeof(str) + end
define word-line-content	  as line-file-content sizeof(str) + end
define string.a			  as word-line-content sizeof(str) + end
define string.b			  as string.a sizeof(str) + end
define loc			  as string.b sizeof(size_t) 2 * + end
define loc.line			  as 0 + end
define loc.col			  as loc.line sizeof(size_t) + end





// set int-iterator to choose witch mode you want to perfome
// MACROS 
define SIMULATION_MODE	as 1 end
define COMPILATION_MODE as 2 end
// OPERATIONS START ----------------------
define OP_INTRISIC_PLUS as 0 end
define OP_PUSH_INT	as 1 end
define OP_DUMP		as 2 end
define NUM_OF_OPS	as 3 end
// OPERATIONS END ------------------------
define sizeof(VR)	as sizeof(size_t) sizeof(size_t) + end
define sizeof(op)	as 16	end
define ops-count	as sim-stack SIMULATION_STACK_CAPACITY 8 * + end
define ops		as ops-count 8 + end	

define push-op as
  // @stack: type operand
  ops-count 64-> sizeof(op) * ops +
  dup 8 + rot  64<-
	  swap 64<-
  ops-count inc64
end
// LEX FILE SECTION ---------------------------------------
define lex-file as 
  // OPEN THE FILE
  // stack: ptr thats is the file-namme
  O_READONLY swap AT_FDCWD openat
  if dup 0 < do
    stderr usage 
    "ERROR: could not open the file `"	eputs
    input-file-path 64-> nth_argv g-streq eputs
    "`\n"				eputs
    1 exit
  end
  fd swap 64<-
  if statbuffer fd 64-> fstat 0 < do
    stderr usage
    "ERROR: could not mesure the file size\n" eputs
    1 exit
  end
  statbuffer stat.st_size 64-> file-content str.count swap 64<-
  0 
  fd 64->
  MAP_PRIVATE
  PROT_READ
  statbuffer stat.st_size 64->
  null 
  mmap
  file-content str.data swap 64<-

  if file-content 64-> 0 < do
    stderr usage
    "ERROR: Could not memory map the file in lexing-stage\n" eputs
    1 exit
  end
  close drop
  // At this point the file is open and is inside file-content
  loc loc.line 0 64<-
  while file-content str.count 64-> 0 > do
    line-file-content file-content chop-line
    loc loc.line inc64
    while line-file-content str.count 64-> 0 > do
        		line-file-content trim-left
      word-line-content line-file-content chop-word

      //loc loc.line 64-> putd ":" puts loc loc.col 64-> putd ": " puts
      if word-line-content str-> "+" streq do 
	OP_INTRISIC_PLUS 0 push-op
      else if word-line-content str-> "dump" streq do
	OP_DUMP 0 push-op
      else
	//OP_PUSH_INT word-line-content str-> try-lex-int push-op 
	OP_PUSH_INT word-line-content str-> try-lex-int push-op
      end end 
      loc loc.col inc64
    end
    loc loc.col 0 64<-
  end
end
define try-lex-int as 
  string.a str<-
  0 0 while dup string.a str.count-> < do
    dup string.a str.data-> + 8-> ascii_0 -
    rot  10 * +
    swap 1 +
  end drop
end
// SIMULATION SECTION -------------------------------------
define sim-stack-push as 
  if sim-stack-count 64-> SIMULATION_STACK_CAPACITY >= do 
    here false ": ERROR: data stack overflow in simulation mode\n" assert
  end
  //
  sim-stack sim-stack-count 64-> 8 * + swap 64<-
  sim-stack-count inc64
end
define sim-stack-pop as 
  if sim-stack-count 64-> 0 = do
    here false ": ERROR: data stack underflow in simulation mode\n" assert
  end
  sim-stack-count dec64
  sim-stack sim-stack-count 64-> 8 * + 64->
end
define simulate-ops as
  here NUM_OF_OPS 3 = "Exhaustive handling operations in simulate-mode\n" assert
  0 while dup ops-count 64-> < do
    dup sizeof(op) * ops +

    if dup 64-> OP_PUSH_INT	  =  do dup 8 + 64-> sim-stack-push		      end
    if dup 64-> OP_INTRISIC_PLUS  =  do sim-stack-pop sim-stack-pop + sim-stack-push  end
    if dup 64-> OP_DUMP		  =  do sim-stack-pop dump			      end

    drop 
    1 +
  end
end
// COMPILATION SECTION -------------------------------------
define compile-ops as 
  here NUM_OF_OPS 3 = "Exhaustive handling operations in compile-mode\n" assert
  here false "compilation mode is not implemented yet\n" assert
  // TODO:
  //	External commands
  "BITS 64\n" puts
  "dump:\n" puts
  "  push  rbp\n"puts
  "  mov   rbp, rsp\n"puts
  "  sub   rsp, 64\n"puts
  "  mov   QWORD  [rbp-56], rdi\n"puts
  "  mov   QWORD  [rbp-8], 1\n"puts
  "  mov   eax, 32\n"puts
  "  sub   rax, QWORD  [rbp-8]\n"puts
  "  mov   BYTE  [rbp-48+rax], 10\n"puts
  ".L2:\n"puts
  "  mov   rcx, QWORD  [rbp-56]\n"puts
  "  mov   rdx, -3689348814741910323\n"puts
  "  mov   rax, rcx\n"puts
  "  mul   rdx\n"puts
  "  shr   rdx, 3\n"puts
  "  mov   rax, rdx\n"puts
  "  sal   rax, 2\n"puts
  "  add   rax, rdx\n"puts
  "  add   rax, rax\n"puts
  "  sub   rcx, rax\n"puts
  "  mov   rdx, rcx\n"puts
  "  mov   eax, edx\n"puts
  "  lea   edx, [rax+48]\n"puts
  "  mov   eax, 31\n"puts
  "  sub   rax, QWORD  [rbp-8]\n"puts
  "  mov   BYTE  [rbp-48+rax], dl\n"puts
  "  add   QWORD  [rbp-8], 1\n"puts
  "  mov   rax, QWORD  [rbp-56]\n"puts
  "  mov   rdx, -3689348814741910323\n"puts
  "  mul   rdx\n"puts
  "  mov   rax, rdx\n"puts
  "  shr   rax, 3\n"puts
  "  mov   QWORD  [rbp-56], rax\n"puts
  "  cmp   QWORD  [rbp-56], 0\n"puts
  "  jne   .L2\n"puts
  "  mov   eax, 32\n"puts
  "  sub   rax, QWORD  [rbp-8]\n"puts
  "  lea   rdx, [rbp-48]\n"puts
  "  lea   rcx, [rdx+rax]\n"puts
  "  mov   rax, QWORD  [rbp-8]\n"puts
  "  mov   rdx, rax\n"puts
  "  mov   rsi, rcx\n"puts
  "  mov   edi, 1\n"puts
  "  mov   rax, 1\n"puts
  "  syscall\n"puts
  "  nop\n"puts
  "  leave\n"puts
  "  ret\n"puts
  "global _start\n"puts
  "segment .text\n" puts
  "_start:\n" puts
  //"    mov [args_ptr], rsp\n" puts
  // TODO:
  // 	better if-else structure
  //  optype op 
  0 while dup ops-count 64-> < do
   dup sizeof(op) * ops +
   if dup 64-> OP_PUSH_INT = do 
     "    ;; ---- push int (" puts dup 8 + 64-> putd  ")\n" puts
     "    push "	      puts dup 8 + 64-> putd  "\n"  puts
   
   else if dup 64-> OP_INTRISIC_PLUS = do  
     "    ;; ---- op-plus\n"  puts
     "    pop rbx\n"	      puts
     "    pop rax\n"	      puts
     "    add rax, rbx\n"     puts
     "    push rax\n"	      puts
   
   else if dup 64-> OP_DUMP = do 
     "    ;; ---- call dump\n"	puts
     "    pop rdi\n"		puts
     "    call dump\n"		puts
   end end end drop 
   1 +
  end

   "segment .bss\n"	      puts
   "buffer:    resb " puts BUFFER_MEMORY_CAPACITY dump 
   // drop
end
define print-ops as
  0 while dup ops-count  64-> < do
    dup sizeof(op) * ops +
    "Type: "  eputs dup	    64-> dump
    "Op: "    eputs	8 + 64-> dump
    "--------------------\n" eputs
    1 +
  end drop
end
define main as 
  if argc 2 < do
    stderr usage
    "ERROR: Not enough arguments\n" eputs
    1 exit
  end 

  goffi-mode	  0 64<- // goffi-mode = 0
  input-file-path 0 64<-
  int-iterator	  1 64<- // int-iterator = 1

  // filter CMD arguments
  while int-iterator  64-> argc <= do
    int-iterator      64-> nth_argv // ptr-to(argv[int-iterator])
    if dup "sim" g-streq do
      goffi-mode
      if dup 64-> 0 != do 
	stderr usage
	"ERROR: Can not use two modes at the same time\n" eputs
	1 exit
      end SIMULATION_MODE 64<-

    else if dup "com" g-streq do
      "com\n" puts
      goffi-mode
      if dup 64-> 0 != do 
	stderr usage
	"ERROR: Can not use two modes at the same time\n" eputs
	1 exit
      end COMPILATION_MODE 64<-

    else if dup "-h" g-streq do
      stdout usage
      0 exit
    else 
      input-file-path int-iterator 64-> 64<-
    end end end
    int-iterator inc64
  end
  // TOOD
  //  OPEN FILE
  //  LEX FILE
  //  SIM-COM mode
  //  assert file-path exits
  // OPEN FILE -----------------------------


  if argc 3 < do 
    stderr usage
    "ERROR: No input file is provided\n" eputs
    1 exit
  end
  input-file-path 64-> nth_argv // FILE ptr
  lex-file // :3 
  goffi-mode 64-> 

  if dup SIMULATION_MODE = do  
    simulate-ops
  else if dup COMPILATION_MODE = do  
    compile-ops
  else
    stderr usage
    here eputs ": ERROR: Unknown subcommand\n" eputs
    1 exit
  end end 
  drop
end
//main
// 420 putd

"1" isdigit dump
//main
0 exit
